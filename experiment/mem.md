# 寄存器与储存器

寄存器组（Register File）与存储器（Memory）是数字系统中的记忆器件，用来存放程序和数据。从程序员的角度来看，CPU的状态由其寄存器及存储器中的信息唯一确定。其中寄存器包括程序计数器PC、通用寄存器，存储器指主存。我们可以将计算机看成一个巨大的有限状态自动机，当这些存储部件的中的信息确定后，计算机的状态也确定了。在没有外部输入时，计算机后续的运行状态也是唯一确定的。

## 寄存器与寄存器组

寄存器通过D触发器实现，寄存器组可以通过多个D触发器组成，至于怎么实现，在先前的章节已经教过你了，往前翻翻吧。

## 储存器

存储器是一组存储单元，用于在计算机中存储二进制的数据。存储器的端口包括：输入端、输出端和控制端口。输入端口包括：读/写地址端口、数据输入端口等；输出端口一般指的是数据输出端口；控制端口包括时钟端和读/写控制端口。

## 寄存器与储存器的异同

虽然寄存器和存储器都是用来存储状态信息的，但是它们在用途和实现上有较大的区别：

- 寄存器一般要求存取速度快、并行访问要求高，所以通常寄存器的容量较小。在CPU中，PC及通用寄存器会经常被访问，因此存取的时延要求在一个时钟周期内。对于单周期CPU，每个时钟周期往往要求同时读取2个通用寄存器并完成1个寄存器的写回。在要求较高的时候，有可能寄存器组输出的结果需要异步输出，即不在时钟沿上读取，输出随着输入地址实时改变。在这样高的要求下，寄存器组的大小不可能太大，否则会消耗非常多的资源。
- 主存一般容量较大，但是读写时间较长，并且读写过程有严格的时序要求。
- 在Verilog中，虽然寄存器组和存储器的描述都是二维数组的方式。但是，编译和综合过程中会根据代码访问的要求来选择具体的实现方式。例如，当代码中没有严格在时钟信号沿上进行读写时，系统会认为该存储单元的读写要求较高，直接采用FPGA逻辑单元实现。这种实现方式消耗的资源巨大，一般只能支持数K量级的存储单元。如果要求大量的此类存储功能，系统可能会花很长时间进行编译综合，甚至无法实现。如果一个存储单元的访问严格按照时序要求，仅在时钟沿上进行每次单个单元的读写时，系统可以用大容量的M10K实现存储，一般可以支持到数百K字节的容量。因此，在实验中对存储器的读写应特别关注，避免用高级语言的二维数组的思路来看待存储器，否则会造成很多意想不到的后果。

## 储存器的实现

Verilog中，可以通过二维数组定义储存器。

```verilog
reg [7:0] memory_array [31:0];
```

但就像我们上面说的那样，这种定义方法会消耗大量的FPGA逻辑单元，所以实际上这个定义方法常用于寄存器组。使用储存器时，我们常常通过直接生成Xilinx IP核完成。

在IP Catalog中搜索memory，并选中Block Memory Generator，开始生成RAM  

![RAM IP核配置1](/img/Vivado_bram_inst_1.png "RAM IP核配置1")

选择简单双端口，并勾选后面的使用用同一时钟  

![RAM IP核配置2](/img/Vivado_bram_inst_2.png "RAM IP核配置2")  

配置写端口所需要的位宽和深度，根据你的需要配置  

![RAM IP核配置3](/img/Vivado_bram_inst_3.png "RAM IP核配置3")

配置读端口所需要的位宽和深度，根据你的需要配置  

![RAM IP核配置4](/img/Vivado_bram_inst_4.png "RAM IP核配置4")

配置初始化文件，这会让RAM在上电时就会在内部保存一些数据，这个我们暂时用不到。用于初始化的文件是coe文件，有兴趣可以搜索一下这个文件的编写方法。  

剩余的具体配置项以及读写时序请参考Vivado的官方文档[Block Memory Generator v8.4 Product Guide (PG058)](https://docs.xilinx.com/v/u/en-US/pg058-blk-mem-gen)，其中Ch3. Designing with the Core章节描述了IP核的内部设计以及工作模式，P46页起是读写时序，请自行阅读并尝试对RAM进行读写。  

例化好的IP核可以直接打开一个Example Design，方法是在IP核上右键->Open Example Design，有需要可自行参考。  

## 练习

例化一个简单双端口RAM，并尝试对它进行读写，了解一下与真实双端口RAM的区别。