# 译码器与编码器

译码器和编码器是数字系统中的常用电路，也是组合逻辑电路中的主要组成元件之一。在CPU中，译码器通常用于将命令转化为某一模块的使能，而编码器常用于从使能信号中指示状态。

## 译码器

以2-4译码器为例。  

译码器的功能是，将输入的数据转换为对应输出线路的高电平，真值表如下  

| x0 | x1 | y0 | y1 | y2 | y3 
| :--: | :--: | :--: | :--: | :--: | :--: |
| 0 | 0 | 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 | 0 | 0 |
| 1 | 0 | 0 | 0 | 1 | 0 |
| 1 | 1 | 0 | 0 | 0 | 1 |  

如果需要，可以加上一个使能端  

| en | x0 | x1 | y0 | y1 | y2 | y3 
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0 | x | x | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 0 | 0 | 1 | 0 |
| 1 | 1 | 1 | 0 | 0 | 0 | 1 |  

表格中x表示不关心的值。  

这里我们使用的是高电平有效，如果需要，你可以改成低电平有效。  

由此，我们可以写出以下代码对2-4译线器进行描述  

```verilog
module decode24(
    input       [1:0]   x_i,
    input               en_i,
    output  reg [3:0]   y_o
    );

    always @(*) begin
        if(en_i) begin
            case(x_i)
                2'b00 : y_o = 4'b0001;
                2'b01 : y_o = 4'b0010;
                2'b10 : y_o = 4'b0100;
                2'b11 : y_o = 4'b1000;
            endcase
        end else begin
            y_o = 4'b0000;
        end
    end

endmodule
```
可以查看RTL图了解一下这样的电路会被综合成什么样子。  

也可以通过下面的代码进行描述  

```verilog
module decode24(
    input       [1:0]   x_i,
    input               en_i,
    output  reg [3:0]   y_o
    );

    always @(*) begin
        casex({en_i, x_i})
            3'b000 : y_o = 4'b0001;
            3'b001 : y_o = 4'b0010;
            3'b010 : y_o = 4'b0100;
            3'b011 : y_o = 4'b1000;
            3'b1xx : y_o = 4'b0000;
        endcase
    end

endmodule
```

`{en_i, x_i}`表示将这两个信号进行拼接，casex表示条件中包含`x`，即不关心的条件。这个例子主要介绍的是if与case嵌套时编译器会如何翻译电路，对于我们来说，出于可读性的考虑，尽量不要这么写。  

但是，更加不要if多次嵌套，请结合上例思考一下，如果if嵌套过多会形成什么样的电路。注意，if是带有优先级的，而case想要存在优先级必须使用casex。  

if和case的嵌套应该如何控制呢？if应该用于最外层的全局控制信号，比如使能、复位信号等，而case用于细分的控制逻辑。正常来说，除了状态机以外尽量不要if套case后再继续嵌套下去，除非你很清楚你在干什么。  

## 编码器

编码器是译码器的逆运算，真值表如下  

| en | x0 | x1 | x2 | x3 | y0 | y1 
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0 | x | x | x | x | 0 | 0 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 | 0 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 | 1 | 0 |
| 1 | 0 | 0 | 0 | 1 | 1 | 1 |  

这里我们采用独热码，即每一组数据中只有一位为1。  

>请自行思考，如果输入端有两位以上都出现了1，输出应该是什么值？   

Verilog代码描述如下
```verilog  
module encode42(
    input       [3:0]   x_i,
    input               en_i,
    output  reg [1:0]   y_o
);
    

    always @(*) begin
        if (en_i) begin
            case (x_i)
                4'b0001 : y_o = 2'b00;
                4'b0010 : y_o = 2'b01;
                4'b0100 : y_o = 2'b10;
                4'b1000 : y_o = 2'b11;
                default : y_o = 2'b00;
            endcase
        end else begin
            y_o = 2'b00;
        end
    end
endmodule
```
根据上述代码回答上面的问题。如果你还不理解，可以尝试写一个testbench去看一下。

>如果需要在输入端有两位以上都出现了1时，输出高阻态，上面的代码又应该如何修改？ 

这里的case中出现了default语句，default指的是如果case的信号并没有落在列出的condition中电路会如何行为。这牵扯到了一个很重要的概念：分支覆盖。

## 分支覆盖

首先我们来思考一下，在平常编程的时候，使用if或者switch语句来书写分支结构，如果没有满足条件，那些变量会有什么改变吗？ 

答案是什么都不会改变，因为条件不满足，不会执行任何的赋值语句，变量值保持不变。  

但在硬件上，保持不变就非常麻烦了。在数字电子技术中我们学过，只有时序逻辑有保持的功能，组合逻辑是没有保持数据的能力的。但当你写出没有被覆盖的分支时，编译器的默认操作就是会将这个值保持不变，对于组合逻辑来说就会增加一个锁存器(Latch)，这会导致很多意想不到的结果，Vivado也会将这个情况作为一个Critical Warning输出，在编程时需要避免出现这种情况。  

怎么避免呢？当然是把分支写全，if要有else配对，case如果不写完所有情况一定要加default，让编译器能找到所有情况的描述，从而综合出正确的组合逻辑电路。  

如果是时序逻辑的话，就不用担心这个问题了，但是出于代码规范和可读性的考虑，在需要保持原值时，还是将赋值语句写全为好。具体可以参考Verilog基础回顾中的代码。  

## 练习

根据74LS138的数据手册，编写一个相同功能的3-8译码器，尝试通过现有的2-4译码器完成搭建，而不是直接使用case语句。